name: Deploy Skedy AI to Kamatera

on:
  push:
    branches: [ main ]  # Changed from master to main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: kamatera

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        printf '%s\n' "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        eval "$(ssh-agent -s)"
        ssh-add ~/.ssh/deploy_key
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        SSH_KNOWN_HOSTS: ${{ secrets.SSH_KNOWN_HOSTS }}

    - name: Deploy Skedy AI to Kamatera (Zero-Downtime)
      run: |
        IMAGE_TAG=$(date +%Y%m%d%H%M)
        echo "üîñ Using image tag: $IMAGE_TAG"

        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no root@45.151.154.42 << EOF
        set -e

        APP_DIR="/root/skedy-ai"
        CONTAINER_NAME="skedy-ai"
        IMAGE_NAME="skedy-ai"

        # Pull latest code first (before stopping anything)
        echo "üì• Pulling latest code..."
        if [ -d "/root/skedy-ai" ]; then
          cd /root/skedy-ai
          git pull origin main
        else
          git clone https://github.com/mesieou/skedy-ai.git /root/skedy-ai
          cd /root/skedy-ai
        fi

        # Aggressive Docker cleanup to free maximum space before building
        echo "üßπ Aggressive Docker cleanup to free maximum space..."

        # Show disk usage before cleanup
        echo "üìä Disk usage before cleanup:"
        df -h / | grep -E '^/dev/' || true
        docker system df || true

        # Stop and remove all stopped containers
        docker container prune -f || true

        # Remove all unused networks
        docker network prune -f || true

        # Remove all unused volumes (be careful - this removes unused volumes)
        docker volume prune -f || true

        # Remove only dangling images (untagged) - SAFE
        docker image prune -f || true

        # Clean build cache (safe to remove)
        docker builder prune -a -f || true

        # SAFE: Remove old skedy-ai images but keep last 3 versions (for rollback safety)
        # This targets only our specific images, not all unused images
        docker images skedy-ai --format "table {{.Tag}}" | grep -E '^[0-9]{12,14}\$' | sort -r | tail -n +4 | xargs -r -I {} docker rmi "skedy-ai:{}" 2>/dev/null || true

        # SAFE: Remove only unused networks and stopped containers (not images)
        docker system prune -f || true

        # Show disk usage after aggressive cleanup
        echo "üìä Disk usage after aggressive cleanup:"
        df -h / | grep -E '^/dev/' || true
        docker system df || true

        # Build new Docker image with timestamp tag (don't overwrite existing)
        TIMESTAMP=\$(date +%Y%m%d%H%M%S)
        NEW_IMAGE="skedy-ai:\$TIMESTAMP"
        echo "üî® Building new Docker image: \$NEW_IMAGE"

        if ! docker build -t "\$NEW_IMAGE" .; then
          echo "‚ùå Docker build failed - keeping existing containers running"
          exit 1
        fi

        # Create .env file with secrets
        cat > .env << ENVEOF
        NODE_ENV=production
        NEXT_TELEMETRY_DISABLED=1
        NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY }}
        SUPABASE_SECRET_KEY=${{ secrets.SUPABASE_SECRET_KEY }}
        VOICE_REDIS_HOST=${{ secrets.VOICE_REDIS_HOST }}
        VOICE_REDIS_PORT=${{ secrets.VOICE_REDIS_PORT }}
        VOICE_REDIS_DB=${{ secrets.VOICE_REDIS_DB }}
        VOICE_REDIS_PASSWORD=${{ secrets.VOICE_REDIS_PASSWORD }}
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        OPENAI_WEBHOOK_SECRET=${{ secrets.OPENAI_WEBHOOK_SECRET }}
        TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}
        TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}
        TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}
        GOOGLE_MAPS_API_KEY=${{ secrets.GOOGLE_MAPS_API_KEY }}
        DEMO_REMOVALIST_BUSINESS_ID=${{ secrets.DEMO_REMOVALIST_BUSINESS_ID }}
        DEMO_MANICURIST_BUSINESS_ID=${{ secrets.DEMO_MANICURIST_BUSINESS_ID }}
        DEMO_PLUMBER_BUSINESS_ID=${{ secrets.DEMO_PLUMBER_BUSINESS_ID }}
        CRON_SECRET=${{ secrets.CRON_SECRET }}
        SENTRY_DSN=${{ secrets.SENTRY_DSN }}
        SENTRY_API_KEY=${{ secrets.SENTRY_API_KEY }}
        ENVEOF

        # Create temporary docker-compose file with new image
        sed "s|skedy-ai:latest|\$NEW_IMAGE|g" docker-compose.cron.yml > docker-compose.new.yml

        # Start new containers on different ports for testing
        echo "üß™ Starting new containers for testing..."
        sed -i 's|"3000:3000"|"3001:3000"|g' docker-compose.new.yml

        if ! docker-compose -f docker-compose.new.yml up -d; then
          echo "‚ùå Failed to start new containers - keeping existing ones running"
          docker-compose -f docker-compose.new.yml down || true
          rm -f docker-compose.new.yml
          exit 1
        fi

        # Wait for new containers to be ready
        echo "‚è≥ Waiting for new containers to be ready..."
        sleep 10

        # Get container IDs (normalize multiple lines)
        NEW_APP_CONTAINERS=\$(docker-compose -f docker-compose.new.yml ps -q skedy-app | tr '\n' ' ')
        NEW_CRON_CONTAINERS=\$(docker-compose -f docker-compose.new.yml ps -q availability-cron | tr '\n' ' ')

        echo "Debug: New app container IDs: \$NEW_APP_CONTAINERS"
        echo "Debug: New cron container IDs: \$NEW_CRON_CONTAINERS"

        # Verify all containers are running
        check_containers_running() {
          local containers=\$1
          for c in \$containers; do
            status=\$(docker inspect -f '{{.State.Running}}' "\$c" 2>/dev/null || echo "false")
            if [ "\$status" != "true" ]; then
              echo "‚ùå Container \$c is not running"
              return 1
            fi
          done
          return 0
        }

        if ! check_containers_running "\$NEW_APP_CONTAINERS" || ! check_containers_running "\$NEW_CRON_CONTAINERS"; then
          echo "‚ùå One or more new containers failed to start - rolling back"
          docker-compose -f docker-compose.new.yml down || true
          exit 1
        fi

        # Retry health checks with multiple attempts
        MAX_RETRIES=5
        for c in \$NEW_APP_CONTAINERS; do
          echo "üîç Testing health for container \$c..."
          attempt=1
          until curl -f http://localhost:3001/api/health --max-time 10; do
            if [ \$attempt -ge \$MAX_RETRIES ]; then
              echo "‚ùå Container \$c failed health check after \$MAX_RETRIES attempts"
              docker-compose -f docker-compose.new.yml down || true
              exit 1
            fi
            echo "‚ö†Ô∏è Health check failed, retrying in 5s (attempt \$attempt/\$MAX_RETRIES)..."
            attempt=\$((attempt+1))
            sleep 5
          done
          echo "‚úÖ Container \$c passed health check"
        done

        echo "‚úÖ New containers are healthy - proceeding with deployment"

        # Now stop old containers and start new ones on correct ports
        echo "‚èπÔ∏è Stopping old containers..."
        docker-compose -f docker-compose.cron.yml down || true
        docker stop skedy-ai || true  # fallback for old single container
        docker rm skedy-ai || true

        # Stop test containers
        docker-compose -f docker-compose.new.yml down

        # Tag new image as latest
        docker tag "\$NEW_IMAGE" "skedy-ai:latest"

        # Start new containers on production ports
        echo "üöÄ Starting new containers on production ports..."
        docker-compose -f docker-compose.cron.yml up -d

        # Final verification
        sleep 5
        FINAL_APP_CONTAINER=\$(docker-compose -f docker-compose.cron.yml ps -q skedy-app)
        FINAL_CRON_CONTAINER=\$(docker-compose -f docker-compose.cron.yml ps -q availability-cron)
        FINAL_RUNNING_CONTAINERS=\$(docker ps -q)

        if [ -n "\$FINAL_APP_CONTAINER" ] && [ -n "\$FINAL_CRON_CONTAINER" ] && echo "\$FINAL_RUNNING_CONTAINERS" | grep -q "\$FINAL_APP_CONTAINER" && echo "\$FINAL_RUNNING_CONTAINERS" | grep -q "\$FINAL_CRON_CONTAINER"; then
          echo "‚úÖ Deployment completed successfully!"
          echo "üì± Main app logs:"
          docker logs --tail 5 \$(docker-compose -f docker-compose.cron.yml ps -q skedy-app)
          echo "‚è∞ Cron service logs:"
          docker logs --tail 5 \$(docker-compose -f docker-compose.cron.yml ps -q availability-cron)

          # Clean up old images (keep last 2 versions)
          echo "üßπ Cleaning up old images..."
          docker images skedy-ai --format "table {{.Tag}}" | grep -E '^[0-9]{14}\$' | sort -r | tail -n +3 | xargs -r -I {} docker rmi "skedy-ai:{}" || true
        else
          echo "‚ùå Final verification failed"
          docker-compose -f docker-compose.cron.yml logs
          exit 1
        fi

        # Cleanup
        rm -f docker-compose.new.yml
        EOF
