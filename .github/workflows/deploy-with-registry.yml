name: Deploy Skedy AI via Docker Registry

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value={{date 'YYYYMMDD-HHmmss'}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: kamatera

    steps:
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        printf '%s\n' "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        eval "$(ssh-agent -s)"
        ssh-add ~/.ssh/deploy_key
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        SSH_KNOWN_HOSTS: ${{ secrets.SSH_KNOWN_HOSTS }}

    - name: Deploy to Kamatera (Registry-based)
      run: |
        # Extract the timestamped tag for deployment
        DEPLOY_TAG=$(echo "${{ needs.build-and-push.outputs.image-tag }}" | grep -E '[0-9]{8}-[0-9]{6}' | head -1)
        if [ -z "$DEPLOY_TAG" ]; then
          echo "‚ùå Could not find timestamped tag, falling back to latest"
          DEPLOY_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        fi

        echo "üöÄ Deploying image: $DEPLOY_TAG"

        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no root@45.151.154.42 << EOF
        set -e

        APP_DIR="/root/skedy-ai"
        NEW_IMAGE="$DEPLOY_TAG"

        # Ensure app directory exists and pull latest code for configs
        if [ ! -d "\$APP_DIR" ]; then
          git clone https://github.com/mesieou/skedy-ai.git \$APP_DIR
        fi
        cd \$APP_DIR
        git pull origin main

        # Stop host-level nginx if running (we use Docker nginx)
        if systemctl is-active --quiet nginx 2>/dev/null; then
          echo "üõë Stopping host-level nginx (using Docker nginx instead)..."
          systemctl stop nginx
          systemctl disable nginx
        fi

        echo "üßπ Aggressive Docker cleanup to free maximum space..."

        # Show disk usage before cleanup
        echo "üìä Disk usage before cleanup:"
        df -h / | grep -E '^/dev/' || true
        docker system df || true

        # Stop and remove all stopped containers
        docker container prune -f || true

        # Remove all unused networks
        docker network prune -f || true

        # Remove all unused volumes (be careful - this removes unused volumes)
        docker volume prune -f || true

        # Remove only dangling images (untagged) - SAFE
        docker image prune -f || true

        # Clean build cache (safe to remove)
        docker builder prune -a -f || true

        # Remove ALL timestamped images (keep only 'latest' locally)
        # GHCR stores the history, so we don't need local copies
        docker images ghcr.io/mesieou/skedy-ai --format "{{.Repository}}:{{.Tag}}" \
          | grep -E ':[0-9]{8}-[0-9]{6}$' \
          | xargs -r docker rmi -f 2>/dev/null || true

        # SAFE: Remove only unused networks and stopped containers (not images)
        docker system prune -f || true

        # Show disk usage after cleanup
        echo "üìä Disk usage after aggressive cleanup:"
        df -h / | grep -E '^/dev/' || true
        docker system df || true

        echo "üìä Disk usage before deployment:"
        df -h / | grep -E '^/dev/' || true

        echo "üì• Pulling new image: \$NEW_IMAGE"
        if ! docker pull "\$NEW_IMAGE"; then
          echo "‚ùå Failed to pull image - deployment aborted"
          exit 1
        fi

        # Create .env file with secrets
        cat > .env << ENVEOF
        NODE_ENV=production
        NEXT_TELEMETRY_DISABLED=1
        NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY }}
        SUPABASE_SECRET_KEY=${{ secrets.SUPABASE_SECRET_KEY }}
        VOICE_REDIS_HOST=${{ secrets.VOICE_REDIS_HOST }}
        VOICE_REDIS_PORT=${{ secrets.VOICE_REDIS_PORT }}
        VOICE_REDIS_DB=${{ secrets.VOICE_REDIS_DB }}
        VOICE_REDIS_PASSWORD=${{ secrets.VOICE_REDIS_PASSWORD }}
        OPENAI_API_KEY_DEMO=${{ secrets.OPENAI_API_KEY_DEMO }}
        OPENAI_API_KEY_TIGA=${{ secrets.OPENAI_API_KEY_TIGA }}
        OPENAI_WEBHOOK_SECRET_DEMO=${{ secrets.OPENAI_WEBHOOK_SECRET_DEMO }}
        OPENAI_WEBHOOK_SECRET_TIGA=${{ secrets.OPENAI_WEBHOOK_SECRET_TIGA }}
        TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}
        TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}
        TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}
        GOOGLE_MAPS_API_KEY=${{ secrets.GOOGLE_MAPS_API_KEY }}
        STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
        STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }}
        STRIPE_WEBHOOK_SECRET_MAIN=${{ secrets.STRIPE_WEBHOOK_SECRET_MAIN }}
        DEMO_REMOVALIST_BUSINESS_ID=${{ secrets.DEMO_REMOVALIST_BUSINESS_ID }}
        DEMO_MANICURIST_BUSINESS_ID=${{ secrets.DEMO_MANICURIST_BUSINESS_ID }}
        DEMO_PLUMBER_BUSINESS_ID=${{ secrets.DEMO_PLUMBER_BUSINESS_ID }}
        CRON_SECRET=${{ secrets.CRON_SECRET }}
        SENTRY_DSN=${{ secrets.SENTRY_DSN }}
        SENTRY_API_KEY=${{ secrets.SENTRY_API_KEY }}
        NEXT_PUBLIC_GOOGLE_ANALYTICS_ID=${{ secrets.NEXT_PUBLIC_GOOGLE_ANALYTICS_ID }}
        NEXT_PUBLIC_FACEBOOK_PIXEL_ID=${{ secrets.NEXT_PUBLIC_FACEBOOK_PIXEL_ID }}
        ENVEOF

        # Also create .env.local for Next.js runtime environment loading
        cp .env .env.local

        # Create docker-compose file with new image
        cat > docker-compose.registry.yml << COMPOSEEOF
        version: '3.8'

        services:
          # Main Next.js Application
          skedy-ai:
            image: \$NEW_IMAGE
            environment:
              - NODE_ENV=production
              - NEXT_TELEMETRY_DISABLED=1
            env_file:
              - .env
            restart: unless-stopped
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 40s
            networks:
              - skedy-network

          # Availability Rollover Cron Job
          availability-cron:
            image: \$NEW_IMAGE
            command: ["npx", "tsx", "scripts/availability-cron.ts"]
            environment:
              - NODE_ENV=production
              - NEXT_TELEMETRY_DISABLED=1
            env_file:
              - .env
            restart: unless-stopped
            depends_on:
              - skedy-ai
            networks:
              - skedy-network

          # Nginx Reverse Proxy
          nginx:
            image: nginx:alpine
            ports:
              - "80:80"
              - "443:443"
            volumes:
              - ./nginx.conf:/etc/nginx/nginx.conf:ro
              - /etc/letsencrypt:/etc/letsencrypt:ro
              - /var/www/certbot:/var/www/certbot:ro
            restart: unless-stopped
            depends_on:
              - skedy-ai
            networks:
              - skedy-network

        networks:
          skedy-network:
            driver: bridge
        COMPOSEEOF

        # Zero-downtime deployment with health checks
        echo "üß™ Starting new containers for testing on port 3001..."

        # Create test compose file (app only, no nginx to avoid port conflicts)
        cat > docker-compose.test.yml << TESTEOF
        version: '3.8'
        services:
          skedy-ai:
            image: \$NEW_IMAGE
            ports:
              - "3001:3000"
            environment:
              - NODE_ENV=production
              - NEXT_TELEMETRY_DISABLED=1
            env_file:
              - .env
            restart: unless-stopped
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 40s
            networks:
              - skedy-network
        networks:
          skedy-network:
            driver: bridge
        TESTEOF

        # Try to start test containers
        if ! docker compose -f docker-compose.test.yml up -d; then
          echo "‚ùå Failed to start test containers - keeping old containers running"
          docker compose -f docker-compose.test.yml down || true
          rm -f docker-compose.test.yml
          echo "üîÑ Old containers remain active - no downtime occurred"
          exit 1
        fi

        # Wait and test health
        echo "‚è≥ Waiting for containers to be ready..."
        sleep 15

        # Health check with retries
        MAX_RETRIES=5
        HEALTH_CHECK_PASSED=false

        for attempt in \$(seq 1 \$MAX_RETRIES); do
          if curl -f http://localhost:3001/api/health --max-time 10; then
            echo "‚úÖ Health check passed on attempt \$attempt"
            HEALTH_CHECK_PASSED=true
            break
          elif [ \$attempt -eq \$MAX_RETRIES ]; then
            echo "‚ùå Health check failed after \$MAX_RETRIES attempts - keeping old containers running"
            docker compose -f docker-compose.test.yml logs
            docker compose -f docker-compose.test.yml down || true
            rm -f docker-compose.test.yml
            echo "üîÑ Old containers remain active - no downtime occurred"
            exit 1
          else
            echo "‚ö†Ô∏è Health check failed, retrying in 5s (attempt \$attempt/\$MAX_RETRIES)..."
            sleep 5
          fi
        done

        # Only proceed if health check passed
        if [ "\$HEALTH_CHECK_PASSED" = "true" ]; then
          echo "‚úÖ New containers are healthy - proceeding with zero-downtime switch"

          # Stop old containers ONLY after confirming new ones are healthy
          echo "‚èπÔ∏è Stopping old containers..."
          docker compose -f docker-compose.cron.yml down || true
          docker compose -f docker-compose.registry.yml down || true

          # Stop test containers
          echo "üîÑ Switching from test containers to production..."
          docker compose -f docker-compose.test.yml down

          # Start production containers with the same healthy image
          echo "üöÄ Starting production containers..."
          docker compose -f docker-compose.registry.yml up -d

          # Final verification
          sleep 10
          if curl -f http://localhost:3000/api/health --max-time 10; then
            echo "‚úÖ Zero-downtime deployment completed successfully!"
            echo "üì± Application logs:"
            docker compose -f docker-compose.registry.yml logs --tail 5 skedy-ai
            echo "‚è∞ Cron service logs:"
            docker compose -f docker-compose.registry.yml logs --tail 5 availability-cron
            echo "üåê Nginx logs:"
            docker compose -f docker-compose.registry.yml logs --tail 5 nginx

            echo "üìä Final disk usage:"
            df -h / | grep -E '^/dev/' || true
          else
            echo "‚ùå Final health check failed - attempting rollback"
            docker compose -f docker-compose.registry.yml logs
            echo "üîÑ This should not happen as test containers were healthy"
            exit 1
          fi
        fi

        # Cleanup
        rm -f docker-compose.test.yml

        echo "üéâ Registry-based deployment completed!"
        echo "üì¶ Deployed image: \$NEW_IMAGE"
        EOF
